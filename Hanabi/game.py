import Hanabi.hanabi_deck as hanabi_deck
import Hanabi.player as Player

class Game:
    """
    Class representing the Hanabi Game.

    This class handles all interactions between players, cards, the board,
        the deck, and the discard pile. 

    By separating the game from the server's code, it is simpler to support
        multiple games on the server at a time using some sort of game ID.
    """

    def __init__(self, players, gameid=None, difficulty=0, password=None):
        """
        Constructor for game.

        This method effectively 'sets up' a game of Hanabi. It 
            - creates the deck
            - deals the hands

        :param: players - list of Player objects
        :param: difficulty - number representing difficulty level. Default to 0
            Difficulties:
                **Insert description of difficulties when we figure that out.

        Support for future support of multiple games
            :param: password - string password for game, optional
            :param: id - game uuid. Identifier of games on server
                Will be required, generated by server when new game is created.
        """
        self.deck = hanabi_deck.Deck(difficulty)
        self.current_player = 0
        self.players = []
        self.gameid = gameid
        self.password = password
        self.difficulty = difficulty
        self.board = create_board(difficulty)
        self.discard_pile = create_board(difficulty)

        hands = self.deck.deal(len(players))
        for i in range(len(players)):
            newPlayer = Player.Player(players[i])
            newPlayer.deal(hands[i])
            self.players.append(newPlayer)


    def play(self, card):
        #Do stuff
        if self.valid_move(card):
            self.board.append(card)
            self.log_played(card)
        else:
            self.discard.append(card)
            self.log_play_failed(card)
        self.next_turn()

    def discard(self, card):
        #Do stuff
        self.next_turn()
        self.log_discarded(card)
        pass

    def give_hint(self, target, information):
        #Do stuff
        target.get_hint(information['indices'], information['type'])
        self.log_hint(target, information)
        self.next_turn()

    def draw(self):
        """
        """
        return self.deck.pop()

    def log_played(self, card):
        message = self.players[self.current_player].name + ' played ' +\
                string_card(card)
        print(message)

    def log_play_failed(self, card):
        message = self.players[self.current_player].name + ' tried to play ' +\
                string_card(card) + ' and failed. ' + self.fuse
        print(message)

    def log_discarded(self, card):
        message = self.players[self.current_player].name + ' discarded ' +\
                string_card(card)
        print(message)

    def log_hint(self, target, information):
        message = self.players[self.current_player].name + ' told ' + target.name +\
                string_information(information)
        print(message)

    def next_turn(self):
        self.current_player = (self.current_player + 1) % len(self.players)

    def valid_move(self, card):
        if len(self.board[card['color']]) + 1 == card['number']:
            return True
        else:
            return False

def string_card(card):
    return card.color + ' ' + str(card.number)

def string_information(information):
    return ''


def create_board(difficulty):
    board = {}
    colors = ['red', 'blue', 'green', 'yellow', 'white']
    for color in colors:
        board[color] = []
    return board
